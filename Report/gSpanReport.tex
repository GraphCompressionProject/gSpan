\documentclass[a4paper,12pt]{article}
\usepackage[top=2.54cm, bottom=2.54cm, left=3.18cm, right=3.18cm]{geometry}
\usepackage{ctex}
\usepackage[colorlinks,bookmarksnumbered=true,bookmarksopen=true,CJKbookmarks=true,linkcolor=red,anchorcolor=black,citecolor=black]{hyperref}
\usepackage{amsthm}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{ccmap}
\usepackage{listings}
\usepackage{color}
\usepackage{bbding}
\usepackage{url}
\usepackage{movie15}
\usepackage{booktabs,longtable}
\usepackage{mdwlist}
\usepackage{subfigure}
\usepackage{pifont}
\usepackage{epstopdf}
\usepackage{float}
\usepackage{titlesec}
\usepackage[labelsep=space]{caption}
\usepackage{multirow,paralist}
\usepackage[title,titletoc]{appendix}
\usepackage[svgnames,x11names]{xcolor}
\usepackage[titles,subfigure]{tocloft}
\usepackage{fancyhdr}
\usepackage{lastpage}
\pagestyle{fancy}
%\renewcommand{\headrulewidth}{1pt}  %页眉线宽，设为0可以去页眉线
\lhead{\small{gSpan实验报告}}
\chead{}
\rhead{\small{马凌霄(1501111302)}}
\lfoot{}
\cfoot{}
\rfoot{Page \thepage\ of \pageref{LastPage}}

  \def\CU@definezihao#1#2#3{
  \def#1{\fontsize{#2}{#3}\selectfont}}

\CU@definezihao{\zihaochu}{42}{50}
\CU@definezihao{\zihaoxiaochu}{36}{44}
\CU@definezihao{\zihaoyi}{28}{34}
\CU@definezihao{\zihaoer}{22}{26}
\CU@definezihao{\zihaoxiaoer}{18}{22}
\CU@definezihao{\zihaosan}{15.7}{19}
\CU@definezihao{\zihaosi}{14}{17}
\CU@definezihao{\zihaoxiaosi}{12}{14}
\CU@definezihao{\zihaowu}{10.5}{12}
\CU@definezihao{\zihaoxiaowu}{9}{11}
\CU@definezihao{\zihaoliu}{7.875}{9}
\CU@definezihao{\zihaoqi}{5.25}{6}

\titleformat{\section}{\zihaosi\bfseries}{$\S\;$\thesection}{1em}{}
\titleformat{\subsection}{\zihaoxiaosi\bfseries}{\thesubsection}{1em}{}
\titleformat{\subsubsection}{\zihaoxiaosi\bfseries}{\thesubsubsection}{1em}{}

\usepackage{tabularx}
\newcommand{\PreserveBackslash}[1]{\let \temp =\\#1 \let \\ = \temp}
\newcolumntype{C}[1]{>{\PreserveBackslash\centering}p{#1}}
\newcolumntype{R}[1]{>{\PreserveBackslash\raggedleft}p{#1}}
\newcolumntype{L}[1]{>{\PreserveBackslash\raggedright}p{#1}}

%\renewcommand{\figurename}{\zihaowu{Figure}}

\makeatletter
  \newcommand\figcaption{\def\@captype{figure}\caption}
  \newcommand\tabcaption{\def\@captype{table}\caption}
\makeatother

\usepackage{listings}
\lstset{tabsize=4, %
  frame=single, %把代码用带有阴影的框圈起来
  keywordstyle=\color[rgb]{0,0,1},
  commentstyle=\color[rgb]{0.133,0.545,0.133},
  stringstyle=\color[rgb]{0.627,0.126,0.941},
  %commentstyle=\color{red!50!green!50!blue!50},% 浅灰色的注释
  rulesepcolor=\color{red!20!green!20!blue!20},% 代码块边框为淡青色
  %keywordstyle=\color{blue!90}\bfseries, %代码关键字的颜色为蓝色，粗体
  showstringspaces=false,% 不显示代码字符串中间的空格标记
  stringstyle=\ttfamily, % 代码字符串的特殊格式
  keepspaces=true, %
  breakindent=22pt, %
  numbers=left,%左侧显示行号
  stepnumber=1,%
  numberstyle=\footnotesize, %行号字体用小号
  basicstyle=\footnotesize, %
  showspaces=false, %
  flexiblecolumns=true, %
  breaklines=true, % 对过长的代码自动换行
  breakautoindent=true,%
  breakindent=4em, %
  escapebegin=\begin{CJK*}{GBK}{hei},escapeend=\end{CJK*},
  aboveskip=1em, %代码块边框
  %% added by http://bbs.ctex.org/viewthread.php?tid=53451
  fontadjust,
  captionpos=t,
  framextopmargin=2pt,framexbottommargin=2pt,abovecaptionskip=-3pt,belowcaptionskip=3pt,
  xleftmargin=4em,xrightmargin=4em, % 设定listing左右的空白
  texcl=true,
  % 设定中文冲突，断行，列模式，数学环境输入，listing 数字的样式
  extendedchars=false,columns=flexible,mathescape=true
  % numbersep=-1em
}
\renewcommand{\figurename}{\zihaowu{图}}
\renewcommand{\tablename}{\zihaowu{表}}
\renewcommand{\abstractname}{\zihaoxiaosi{摘 \qquad 要}}
\renewcommand{\contentsname}{\centerline{\Large 目 \qquad 录}}
\renewcommand{\refname}{\centerline{\Large 参考文献}}
%\pagestyle{headings}
\begin{document}
\title{gSpan实验报告}
\author{海量图数据的管理和挖掘}
\date{\today}
\maketitle
\ \\
\noindent\textbf{
作者：马凌霄\\
学号：1501111302\\
院系：信息科学技术学院\\
EMail：xysmlx@gmail.com\\
Repository (Private): \url{https://bitbucket.org/xysmlx/gspan}
}
\newpage
\tableofcontents
\newpage
\section{gSpan算法简述}


\section{程序设计}
\subsection{图-类：class Graph}
\subsubsection{定义代码}
\begin{lstlisting}[language=c++]
struct Vertex
{
	int id;
	int label;
	int seq;
	bool del;

	Vertex(int _id = 0, int _label = 0) : id(_id), label(_label), seq(-1), del(0) {}
	~Vertex() {}
};

struct Edge
{
	int u;
	int v;
	int label;
	int next;
	bool del;

	Edge(int _u = 0, int _v = 0, int _label = 0, int _next = -1) : u(_u), v(_v), label(_label), next(_next), del(0) {}
	~Edge() {}

	bool operator == (const Edge &o) const
	{
		return u == o.u&&v == o.v&&label == o.label;
	}
};

class Graph
{
public:
	Graph()
	{
		memset(head, -1, sizeof(head));
		vn = 0;
		en = 0;
	}
	~Graph() {}

	void init();
	void addv(int id, int label);
	void addse(int u, int v, int label);
	void adde(int u, int v, int label);
	void delse(int u, int v, int label);
	void dele(int u, int v, int label);

public:
	const static int maxv = 250;
	const static int maxe = 510;

public:
	int head[maxv];
	int vn;
	int en;
	Vertex vtx[maxv]; // 0 to vn-1
	Edge edge[maxe]; // 0 to en-1
};
\end{lstlisting}
\subsubsection{设计}
图的存储使用链式前向星来存储。链式前向星的效率高于使用$vector$写的邻接表。

链式前向星的标准设计是：
\begin{itemize}
  \item $head[]$数组：大小为顶点数，存这个点的对应的第一条边在$edge[]$数组的下标
  \item $edge[]$数组：用数组存储边
  \item $Edge$边的结构：
  \item 
  \item 
\end{itemize}

\subsection{输入和重排序-类：class InputFilter}
\subsubsection{定义代码}
\begin{lstlisting}[language=c++]
class InputFilter
{
public:
	struct Node
	{
		int label;
		int cnt;
		Node(int _label = 0, int _cnt = 0) : label(_label), cnt(_cnt) {}
		bool operator < (const Node &o) const // greater
		{
			return cnt > o.cnt;
		}
	};

public:
	void init();
	void addv(int id, int label);
	void adde(int u, int v, int label);
	void filterV();
	void filterE();
	void filter();

public:
	const static int maxv = 1010;
	const static int maxe = 5010;

public:
	int cntv[maxv], cnte[maxe];
	int mpv[maxv], mpe[maxe];
	vector<Vertex> vecv;
	vector<Edge> vece;
	vector<int> listv, liste;
	vector<Node> filterv, filtere;
	vector<string> inputStr;
};
\end{lstlisting}
\subsubsection{设计}

\subsection{DFS Code五元组节点-结构体：struct DFSCodeNode}
\subsubsection{定义代码}
\begin{lstlisting}[language=c++]
struct DFSCodeNode
{
	int a, b;
	int la, lab, lb;

	DFSCodeNode(int _a = -1, int _b = -1, int _la = -1, int _lab = -1, int _lb = -1) : a(_a), b(_b), la(_la), lab(_lab), lb(_lb) {}
	~DFSCodeNode() {}

	bool isForward() const
	{
		return a < b;
	}
	bool isBackward() const
	{
		return a > b;
	}

	bool operator < (const DFSCodeNode &o) const
	{
		if (this->isBackward() && o.isForward()) return 1;
		else if (this->isBackward() && o.isBackward() && b < o.b) return 1;
		else if (this->isBackward() && o.isBackward() && b == o.b&&lab < o.lab) return 1;
		else if (this->isForward() && o.isForward() && a > o.a) return 1;
		else if (this->isForward() && o.isForward() && a == o.a&&la < o.la) return 1;
		else if (this->isForward() && o.isForward() && a == o.a &&la == o.la&&lab < o.lab) return 1;
		else if (this->isForward() && o.isForward() && a == o.a &&la == o.la&&lab == o.lab&&lb < o.lb) return 1;
		return 0;
	}
	bool operator == (const DFSCodeNode &o) const
	{
		return a == o.a&&b == o.b&&la == o.la&&lab == o.lab&&lb == o.lb;
	}
};
\end{lstlisting}
\subsubsection{设计}

\subsection{DFS Code-类：class DFSCode}
\subsubsection{定义代码}
\begin{lstlisting}[language=c++]
class DFSCode
{
public:
	DFSCode()
	{
		dfsCodeList.clear();
		rightPath.clear();
	}
	bool operator < (const DFSCode &o) const
	{
		int minsize = min(dfsCodeList.size(), o.dfsCodeList.size());
		for (int i = 0;i < minsize;i++)
			if (dfsCodeList[i] < o.dfsCodeList[i]) return 1;
		return dfsCodeList.size() < o.dfsCodeList.size();
	}
	bool operator == (const DFSCode &o) const
	{
		if (dfsCodeList.size() != o.dfsCodeList.size()) return 0;
		for (int i = 0;i < (int)dfsCodeList.size();i++)
			if (!(dfsCodeList[i] == o.dfsCodeList[i])) return 0;
		return 1;
	}

public:
	void init();
	void output(); // Output this dfscode
	Graph Convert2Graph();
	bool GenMinDFSCode(Graph &g, DFSCode &ret, int now); // Generate the min dfscode from now
	DFSCode FindMinDFSCode(); // Find the min dfscode of this pattern
	bool isMinDFSCode(); // Is this dfscode the min dfscode?

public:
	vector<DFSCodeNode> dfsCodeList;
	vector<pair<int, int> > rightPath;
};
\end{lstlisting}
\subsubsection{设计}

\subsection{gSpan算法-类：class GSPAN}
\subsubsection{定义代码}
\begin{lstlisting}[language=c++]
class GSPAN
{
public:
	struct FreqEdgeSortNode
	{
		Edge e;
		int cnt;
		FreqEdgeSortNode(Edge _e = Edge(), int _cnt = 0) :e(_e), cnt(_cnt) {}
		bool operator < (const FreqEdgeSortNode &o) const // greater
		{
			return cnt > o.cnt;
		}
	};

public:
	GSPAN() {}
	void init();
	void input(const InputFilter &_inputFilter, double _minSup); // Build relabeled graph
	void output();
	void GenSeedSet(); // Generate the seed edge set
	void DeleteEdgeFlag(const Edge &e); // Label deleted edge
	void DeleteEdge(const Edge &e); // Delete edge from graph
	void DeleteUnFreqEdge(); // Delete unfreq edge
	void RebuildGraph(int id); // Rebuild graph with id
	bool JudgePatternInGraph(Graph &graph, const DFSCode &dfscode, int ith, int now); // DFS, ith = dfscode.dfsCodeList[ith], now = now vertex
	bool isPatternInGraph(Graph graph, const DFSCode &dfscode); // Is this pattern in this graph?
	void SolveFreqPattern(const DFSCode &dfscode); // Work when dfscode is freq pattern
	bool isFreqPattern(const DFSCode &dfscode); // Is dfscode a freq pattern?
	void BuildPattern(DFSCode &dfscode, int loc, int backloc, int maxseq); // DFS build pattern and test, loc = now extend location in rightpath, backloc = -1(forward) or backward location in rightpath, maxseq = max sequence id
	void SubMining(const Edge &base); // Sub-Mining Procedure
	void gSpan(); // Run gSpan

	void debug(); // For debug

public:
	const static int maxGraph = 10010; // Maximum graph number of graph set

public:
	ofstream out; // Output to file
	DFSCode tmpDFSCode; // Temp dfscode

	double minSup; // minimum support
	int minSupDeg; // minSup * cntGraph

	Graph graph[maxGraph]; // 0 to cntGraph-1
	int cntGraph; // Num of graphs in the graph set

	map<Edge, int, EdgeCMP> freqEdgeCnt; // Count edge's frequency
	set<Edge, EdgeCMP> freqEdgeVis; // Visit or not in a graph

	vector<Edge> freqEdge; // Freq edge set
	vector<Edge> unFreqEdge; // Unfreq edge set

	vector<DFSCode> freqPattern; // Freq pattern, the answer
};
\end{lstlisting}
\subsubsection{设计}


\section{程序测试}
\subsection{测试环境}
测试环境如表\ref{tab:environment}所示：

\begin{table}[H]
  \centering
  \caption{\zihaowu 实验环境}
    \begin{tabular}{L{3cm}|L{10cm}}
    \toprule
    项目  & 详细信息\\
    \midrule
    CPU   & AMD Opteron 8380 (2.5GHz, 4 Cores) $\times$ 16 \\
    内存    & 64GB ECC DDR2 \\
    测试所用磁盘 & 2TB 7200RPM HDD (Read: 96.5MB/s) \\
    操作系统  & Ubuntu 12.04.2 LTS x64 \\
    C/C++编译器 & GNU C++ 4.8 \\
    \bottomrule
    \end{tabular}%
  \label{tab:environment}%
\end{table}%

该代码已上传至BitBucket的私有仓库，课程结束后会开源

\subsection{正确性测试}
\subsubsection{测试数据}
\begin{figure}[H]
  \centering
  \includegraphics[width=400 pt]{Input.jpg}
  \caption{\zihaowu 正确性测试的测试数据}\label{fig:input}
\end{figure}

\begin{lstlisting}
t # 0
v 0 3
v 1 4
v 2 2
v 3 3
v 4 2
v 5 2
v 6 4
v 7 3
e 0 1 2
e 1 2 2
e 2 3 3
e 1 3 2
e 3 4 3
e 1 4 4
e 4 5 3
e 3 5 3
e 5 6 4
e 3 6 2
e 6 2 4
e 6 7 2
t # 1
v 0 2
v 1 3
v 2 4
v 3 2
v 4 4
e 0 1 4
e 1 2 2
e 0 2 3
e 2 3 4
e 1 3 3
e 3 4 4
e 1 4 2
t # 2
v 0 4
v 1 3
v 2 2
v 3 3
v 4 4
v 5 2
e 0 1 2
e 1 2 3
e 2 3 2
e 2 4 4
e 1 4 2
e 4 5 3
t # 3
v 0 3
v 1 2
v 2 3
v 3 4
e 0 1 3
e 1 2 3
e 2 3 2
e 3 0 2
e 3 1 4
t # 4
v 0 2
v 1 2
v 2 2
v 3 2
v 4 2
v 5 2
e 0 1 2
e 1 2 3
e 2 3 2
e 3 4 3
e 4 5 2
e 5 0 3
t # -1
\end{lstlisting}

\subsubsection{输出结果}
\begin{figure}[H]
  \centering
  \includegraphics[width=250 pt]{FreqPattern.jpg}
  \caption{\zihaowu 正确性测试的结果}\label{fig:freqpattern}
\end{figure}

\begin{lstlisting}
Seed Set:
2 3 3
2 4 4
3 4 2
Pattern #1:
0 1 2 3 3
Pattern #2:
0 1 2 3 3
1 2 3 2 4
Pattern #3:
0 1 2 3 3
1 2 3 2 4
2 0 4 4 2
Pattern #4:
0 1 2 3 3
1 2 3 2 4
2 0 4 4 2
1 2 3 2 4
Pattern #5:
0 1 2 4 4
Pattern #6:
0 1 2 4 4
1 2 4 2 3
Pattern #7:
0 1 2 4 4
1 2 4 2 3
2 2 3 2 4
Pattern #8:
0 1 3 2 4
\end{lstlisting}

\subsection{运行速度测试}
\subsubsection{测试数据}
测试数据为graph.data：图集合中有10000个图，每个图最大点数不超过250，边数不超过250。
\subsubsection{对照程序}
使用Xifeng Yan, Jiawei Han的原作者的程序 \footnote{\url{http://www.cs.ucsb.edu/~xyan/software/gSpan2009-02-20/gSpan6.tar.gz}}进行运行速度测试的对比，$minSup$阈值选取和运行时间数据如表\ref{tab:runtime}所示。运行时间作图如图\ref{fig:runtime}所示。
\begin{figure}[H]
  \centering
  \includegraphics[width=350 pt]{runtime.eps}
  \caption{\zihaowu 运行时间测试}\label{fig:runtime}
\end{figure}


\begin{table}[H]
  \centering
  \caption{\zihaowu 运行时间测试}
    \begin{tabular}{R{2cm}R{4cm}R{4cm}}
    \toprule
    \multicolumn{1}{c}{minSup} & \multicolumn{1}{c}{My(ms)} & \multicolumn{1}{c}{Yan(ms)} \\
    \midrule
    0.9   & 2050  & 1837 \\
    0.8   & 2790  & 2299 \\
    0.7   & 3520  & 4298 \\
    0.6   & 8510  & 4554 \\
    0.5   & 14920 & 5749 \\
    0.4   & 13690 & 6001 \\
    0.3   & 22620 & 7318 \\
    0.2   & 25940 & 11164 \\
    0.1   & 85820 & 23648 \\
    0.09  & 96650 & 26878 \\
    0.08  & 87780 & 31235 \\
    0.07  & 133020 & 36047 \\
    0.06  & 146220 & 45141 \\
    0.05  & 178760 & 58311 \\
    0.04  & 227410 & 75880 \\
    0.03  & 387420 & 119003 \\
    0.02  & 772316 & 282170 \\
    0.01  & 4421358 & 1175110 \\
    \bottomrule
    \end{tabular}%
  \label{tab:runtime}%
\end{table}%


从表\ref{table:runtime}和图\ref{fig:runtime}看出，本程序的性能不如原作者的程序的性能。还有一些优化可以加入，但是因为时间的原因，所以没有加入程序。

\paragraph{优化策略}
\begin{itemize}
  \item 链式前向星写的图的点数和边数开的较大，可以根据图的大小开；
  \item 将枚举构造频发模式改为在图集合中查找构造频繁模式；
  \item gSpan有很好的并行性，所以可以使用多线程：将每个任务放入一个队列，然后让每个线程从队列中提取任务执行。
\end{itemize}


\appendix
\section{备注}
\subsection{}
\begin{lstlisting}[language=c++]
#include<cstdio>
int main()
{
	return 0;
}
\end{lstlisting}

\end{document}
